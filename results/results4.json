{
    "exercises": [
        {
            "title": "Bilan Hashing",
            "description": "<p>Etant donné une fonction de hachage <span class=\"math inline\">$h(\\left[v_0 \\cdots v_n \\right]) = \\sum_{i=0}^{n} v_i R^{(n-i-1)} \\% M$</span> dans laquelle <span class=\"math inline\">[<em>v</em><sub>0</sub>⋯<em>v</em><sub><em>n</em></sub>]</span> dénote un vecteur de bit et <span class=\"math inline\"><em>R</em></span> et <span class=\"math inline\"><em>M</em></span> sont des facteurs constants.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "xgillard",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/bilan_hashing",
            "archive_properties": {
                "folders": [
                    "bilan_hashing"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Circular LinkedList",
            "description": "<h1 id=\"context\">Context</h1>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/bilan_m1/bilan_m1.pdf\">Description</a> of the implementation exercise and interesting questions to improve your skills.</p>\r\n<p>Fill-in the body of each method (TODO) below in the corresponding textfield. grade: 50% for the correctness of your implementation (correct or not), 50% for the efficiency (efficient or not).</p>\r\n<pre class=\"java\"><code>public class NodeQueue&lt;E&gt; implements Queue&lt;E&gt; {\r\n\r\n    // Variables d’instance\r\n\r\n    private Node&lt;E&gt; marker;\r\n    private int size;\r\n\r\n\r\n    @Override\r\n    public int size() {\r\n        // TODO\r\n        return 0;\r\n    }\r\n\r\n    @Override\r\n    public boolean isEmpty() {\r\n        // TODO\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public E front() throws QueueEmptyException {\r\n        // TODO\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public void enqueue(E element) {\r\n        // TODO\r\n\r\n    }\r\n\r\n    @Override\r\n    public E dequeue() throws QueueEmptyException {\r\n        // TODO\r\n        return null;\r\n    }\r\n}</code></pre>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "category": 2,
                    "text": "Mission 1"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/bilan_m1",
            "archive_properties": {
                "folders": [
                    "bilan_m1"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Global Warming",
            "description": "<h1 id=\"context\">Context</h1>\r\n<p>Assume the following 5x5 matrix:</p>\r\n<pre class=\"java\"><code>int [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};</code></pre>\r\n<p>represented in the array here under:</p>\r\n<p><img src=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/bilan_m2_global_warming/matrix.png\" class=\"align-center\" width=\"200\" alt=\"matrix example\" /></p>\r\n<p>Each entry of the matrix represents an altitude. The objective is to implement a class <span class=\"title-ref\">GlobalWarmingImpl</span> that the method described in <span class=\"title-ref\">GlobalWarming</span> given next.</p>\r\n<p>Given a global water level, all the positions of the matrix with a value &lt;= the water level are flooded (under the water) and thus unsafe. So assuming the water level is 3, all the safe points are green.</p>\r\n<p>The methods you must implement is</p>\r\n<ul>\r\n<li>the computations of the number of safe-points given a specified water level</li>\r\n</ul>\r\n<pre class=\"java\"><code>import java.util.List;\r\n\r\nabstract class GlobalWarming {\r\n\r\n\r\n    final int[][] altitude;\r\n\r\n    /**\r\n     * @param altitude is a n x n matrix of int values representing altitudes (positive or negative)\r\n     */\r\n    public GlobalWarming(int[][] altitude) {\r\n        this.altitude = altitude;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param waterLevel\r\n     * @return the number of entries in altitude matrix that would be above\r\n     *         the specified waterLevel.\r\n     *         Warning: this is not the waterLevel given in the constructor/\r\n     */\r\n    public abstract int nbSafePoints(int waterLevel);\r\n\r\n}</code></pre>\r\n<h1 id=\"preliminary-exercises\">Preliminary exercises</h1>\r\n<pre class=\"java\"><code>int [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};\r\nGlobalWarming gw = new MyGlobalWarming(tab);</code></pre>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                },
                {
                    "category": 2,
                    "text": "Mission 3"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/bilan_m2_global_warming",
            "archive_properties": {
                "folders": [
                    "bilan_m2_global_warming"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Incremental Hash",
            "description": "<p>La fonction de Hash calculée sur le sous tableau t[from,...,from+M-1] est calculée comme suit:</p>\r\n<p><span class=\"math inline\">$hash([from,...,from+M-1])= \\left( \\sum_{i=0}^{M-1} t[from+i] \\cdot R^{(M-1-i)}\\right)\\%Q$</span></p>\r\n<p>Le code pour calculer cette fonction de hash vous est donné. Nous vous demandons de calculer <span class=\"math inline\"><em>h</em><em>a</em><em>s</em><em>h</em>([<em>f</em><em>r</em><em>o</em><em>m</em>, ..., <em>f</em><em>r</em><em>o</em><em>m</em> + <em>M</em> − 1])</span> au départ de <span class=\"math inline\"><em>h</em><em>a</em><em>s</em><em>h</em>([<em>f</em><em>r</em><em>o</em><em>m</em> − 1, ..., <em>f</em><em>r</em><em>o</em><em>m</em> + <em>M</em> − 2])</span> en O(1).</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "category": 2,
                    "text": "Mission 4"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/bilan_m4_incrementalhash",
            "archive_properties": {
                "folders": [
                    "bilan_m4_incrementalhash"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Huffman",
            "description": "<p>Vous devez calculer un arbre de Huffman au départ de la fréquence donnée pour chacune des R lettres (characters).</p>\r\n<p>Pour rappel, dans un arbre de Huffman nous avons que <em>la somme de la fréquence associée à chaque feuille multipliée par la profondeur de celle-ci est minimale</em>.</p>\r\n<p>Par exemple, étant donné les fréquences suivantes:</p>\r\n<p><img src=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/bilan_m5_huffman/huffmanin.png\" class=\"align-center\" width=\"500\" alt=\"Input frequencies\" /></p>\r\n<p>un arbre de Huffman pourrait être:</p>\r\n<p><img src=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/bilan_m5_huffman/huffmanout.png\" class=\"align-center\" width=\"500\" alt=\"Huffman tree\" /></p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "category": 2,
                    "text": "Mission 5"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/bilan_m5_huffman",
            "archive_properties": {
                "folders": [
                    "bilan_m5_huffman"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Connected Components",
            "description": "<p>L'API de la classe <a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/bilan_m6_cc/javadoc.zip\">Graph</a>.</p>\r\n<p>L'API de <a href=\"https://docs.oracle.com/javase/8/docs/api/\">Java</a>.</p>\r\n<pre class=\"java\"><code>public class ConnectedComponents {\r\n  /**\r\n   * @return the number of connected components in g\r\n   */\r\n  public static int numberOfConnectedComponents(Graph g) {\r\n    // TODO\r\n    return 0;\r\n  }\r\n}</code></pre>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "psc",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                },
                {
                    "category": 2,
                    "text": "Mission 6"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/bilan_m6_cc",
            "archive_properties": {
                "folders": [
                    "bilan_m6_cc"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Quizz: Closest Pair",
            "description": "<p>Implémentez un algorithme qui reçoit en entrée un tableau d'entiers et qui trouve deux valeurs issues de tableau dont la somme se rapproche le plus d'une valeur entière donnée <span class=\"math inline\"><em>x</em></span>. Soiet <span class=\"math inline\">(<em>a</em>, <em>b</em>)</span> les deux valeurs trouvées, celles-ci doivent donc minimiser <span class=\"math inline\">|<em>x</em> − (<em>a</em> + <em>b</em>)|</span>. Les deux valeurs peuvent correspondre à la même entrée du tableau.</p>\r\n<p>Par exemple pour le tableau suivant</p>\r\n<pre class=\"java\"><code>int [] input = new int [] {5,10,1,75,150,151,155,18,75,50,30};</code></pre>\r\n<ul>\r\n<li>x=20, il faut retourner [10,10].</li>\r\n<li>x=153, il faut retrouner [1,151]</li>\r\n<li>x=13, il faut retrouner [1,10]</li>\r\n<li>x=140 il faut retourner [75,75]</li>\r\n<li>x=170 il faut retourner [18,151]</li>\r\n</ul>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/closestpair/project.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "midterm"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/closestpair",
            "archive_properties": {
                "folders": [
                    "closestpair"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "LinearProbing",
            "description": "<p>Dans ce exercice il vous est demandé d'implémenter les fonctions <code>resize</code>, <code>put</code> et <code>get</code> d'une table de symbole basé sur le hashage par Linear Probing.</p>\r\n<p>Pour cela la classe suivant vous a été donné. Vous devez completer les <em>TODO</em>.</p>\r\n<pre class=\"java\"><code>import java.util.Arrays;\r\n\r\n/**\r\n* Symbol-table implementation with linear-probing hash table.\r\n*/\r\npublic class LinearProbingHashST&lt;Key, Value&gt; {\r\n\r\nprivate int n;           // number of key-value pairs in the symbol table\r\nprivate int m;           // size of linear probing table\r\nprivate Key[] keys;      // the keys\r\nprivate Value[] vals;    // the values\r\n\r\n\r\n/**\r\n * Initializes an empty symbol table.\r\n */\r\npublic LinearProbingHashST() {this(16);}\r\n\r\n /**\r\n * Initializes an empty symbol table with the specified initial capacity.\r\n */\r\npublic LinearProbingHashST(int capacity) {\r\n    m = capacity;\r\n    n = 0;\r\n    keys = (Key[])   new Object[m];\r\n    vals = (Value[]) new Object[m];\r\n}\r\n\r\npublic int size() {return n;}\r\npublic boolean isEmpty() {return size() == 0;}\r\n\r\n// hash function for keys - returns value between 0 and M-1\r\nprivate int hash(Key key) {\r\n    return (key.hashCode() &amp; 0x7fffffff) % m;\r\n}\r\n\r\n/**\r\n* resizes the hash table to the given capacity by re-hashing all of the keys\r\n*/\r\nprivate void resize(int capacity) {\r\n    //TODO STUDENT\r\n}\r\n\r\n/**\r\n* Inserts the specified key-value pair into the symbol table, overwriting the old\r\n* value with the new value.\r\n*/\r\npublic void put(Key key, Value val) {\r\n    //TODO STUDENT\r\n}\r\n\r\n/**\r\n* Returns the value associated with the specified key.\r\n*/\r\npublic Value get(Key key) {\r\n    //TODO STUDENT\r\n}\r\n}</code></pre>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/EXAM0119LinearProbing/LSINF1121_EXAM0119_LinearProbing.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "exam"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/EXAM0119LinearProbing",
            "archive_properties": {
                "folders": [
                    "EXAM0119LinearProbing"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Global Warming",
            "description": "<h1 id=\"context\">Context</h1>\r\n<p>Assume the following 5x5 matrix:</p>\r\n<pre class=\"java\"><code>int [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};</code></pre>\r\n<p>represented in the array here under:</p>\r\n<p><img src=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/globalwarming_graph/matrix.png\" class=\"align-center\" width=\"200\" alt=\"matrix example\" /></p>\r\n<p>Each entry of the matrix represents an altitude. The objective is to implement a class <span class=\"title-ref\">GlobalWarmingImpl</span> that implements all the methods described in <span class=\"title-ref\">GlobalWarming</span> given next.</p>\r\n<p>A global water level specified in the constructor models the fact that all the positions of the matrix with a value &lt;= the water level are flooded (under the water) and thus unsafe. In the above example, the water level is 3, all the safe points are green.</p>\r\n<p>The method you must implement is the computation of the shortest path between two positions on a same island</p>\r\n<p>we assume that points are <strong>only connected vertially or horizontally</strong>.</p>\r\n<pre class=\"java\"><code>import java.util.List;\r\n\r\nabstract class GlobalWarming {\r\n\r\n    /**\r\n     * A class to represent the coordinates on the altitude matrix\r\n     */\r\n    public static class Point {\r\n\r\n        final int x, y;\r\n\r\n        Point(int x, int y) {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n\r\n        @Override\r\n        public boolean equals(Object obj) {\r\n            Point p = (Point) obj;\r\n            return p.x == x &amp;&amp; p.y == y;\r\n        }\r\n    }\r\n\r\n    final int[][] altitude;\r\n    final int waterLevel;\r\n\r\n\r\n    /**\r\n     * In the following, we assume that the points are connected to\r\n     * horizontal or vertical neighbors but not to the diagonal ones\r\n     * @param altitude is a n x n matrix of int values representing altitudes (positive or negative)\r\n     * @param waterLevel is the water level, every entry &lt;= waterLevel is flooded\r\n     */\r\n    public GlobalWarming(int[][] altitude, int waterLevel) {\r\n        this.altitude = altitude;\r\n        this.waterLevel = waterLevel;\r\n    }\r\n\r\n\r\n    /**\r\n     *\r\n     * @param p1 a safe point with valid coordinates on altitude matrix\r\n     * @param p2 a safe point (different from p1) with valid coordinates on altitude matrix\r\n     * @return the shortest simple path (vertical/horizontal moves) if any between from p1 to p2 using only vertical/horizontal moves on safe points.\r\n     *         an empty list if not path exists (i.e. p1 and p2 are not on the same island).\r\n     */\r\n    public abstract List&lt;Point&gt; shortestPath(Point p1, Point p2);\r\n\r\n}</code></pre>\r\n<h1 id=\"preliminary-exercises\">Preliminary exercises</h1>\r\n<pre class=\"java\"><code>int [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};\r\nGlobalWarming gw = new MyGlobalWarming(tab,3);</code></pre>\r\n<p><img src=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/globalwarming_graph/matrix.png\" class=\"align-center\" width=\"200\" alt=\"matrix example\" /></p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                },
                {
                    "category": 2,
                    "text": "Mission 6"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/globalwarming_graph",
            "archive_properties": {
                "folders": [
                    "globalwarming_graph"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Global Warming",
            "description": "<h1 id=\"context\">Context</h1>\r\n<p>Assume the following 5x5 matrix:</p>\r\n<pre class=\"java\"><code>int [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};</code></pre>\r\n<p>represented in the array here under:</p>\r\n<p><img src=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/globalwarming_unionfind/matrix.png\" class=\"align-center\" width=\"200\" alt=\"matrix example\" /></p>\r\n<p>Each entry of the matrix represents an altitude. The objective is to implement a class <span class=\"title-ref\">GlobalWarmingImpl</span> that implements all the methods described in <span class=\"title-ref\">GlobalWarming</span> given next.</p>\r\n<p>A global water level specified in the constructor models the fact that all the positions of the matrix with a value &lt;= the water level are flooded (under the water) and thus unsafe. In the above example, the water level is 3, all the safe points are green.</p>\r\n<p>The methods you must implement are</p>\r\n<ul>\r\n<li>the number of islands</li>\r\n<li>a test to verify if two positions are on the same island</li>\r\n</ul>\r\n<p>we assume that points are <strong>only connected vertially or horizontally</strong>.</p>\r\n<pre class=\"java\"><code>import java.util.List;\r\n\r\nabstract class GlobalWarming {\r\n\r\n    /**\r\n     * A class to represent the coordinates on the altitude matrix\r\n     */\r\n    public static class Point {\r\n\r\n        final int x, y;\r\n\r\n        Point(int x, int y) {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n\r\n        @Override\r\n        public boolean equals(Object obj) {\r\n            Point p = (Point) obj;\r\n            return p.x == x &amp;&amp; p.y == y;\r\n        }\r\n    }\r\n\r\n    final int[][] altitude;\r\n    final int waterLevel;\r\n\r\n\r\n    /**\r\n     * In the following, we assume that the points are connected to\r\n     * horizontal or vertical neighbors but not to the diagonal ones\r\n     * @param altitude is a n x n matrix of int values representing altitudes (positive or negative)\r\n     * @param waterLevel is the water level, every entry &lt;= waterLevel is flooded\r\n     */\r\n    public GlobalWarming(int[][] altitude, int waterLevel) {\r\n        this.altitude = altitude;\r\n        this.waterLevel = waterLevel;\r\n    }\r\n\r\n\r\n    /**\r\n     * An island is a connected components of safe points wrt to waterLevel\r\n     * @return the number of islands\r\n     */\r\n    public abstract int nbIslands();\r\n\r\n    /**\r\n     *\r\n     * @param p1 a point with valid coordinates on altitude matrix\r\n     * @param p2 a point with valid coordinates on altitude matrix\r\n     * @return true if p1 and p2 are on the same island, that is both p1 and p2 are safe wrt waterLevel\r\n     *        and there exists a path (vertical/horizontal moves) from p1 to p2 using only safe positions\r\n     */\r\n    public abstract boolean onSameIsland(Point p1, Point p2);\r\n\r\n\r\n}</code></pre>\r\n<h1 id=\"preliminary-exercises\">Preliminary exercises</h1>\r\n<pre class=\"java\"><code>int [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};\r\nGlobalWarming gw = new MyGlobalWarming(tab,3);</code></pre>\r\n<p><img src=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/globalwarming_unionfind/matrix.png\" class=\"align-center\" width=\"200\" alt=\"matrix example\" /></p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                },
                {
                    "category": 2,
                    "text": "Mission 5"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/globalwarming_unionfind",
            "archive_properties": {
                "folders": [
                    "globalwarming_unionfind"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Linked List Stack (Implem)",
            "description": "<p>Il vous est demandé d'implémenter l'interface suivante, représentant une pile, en utilisant une liste simplement chainée. Vous devriez avoir au moins un constructeur sans argument, créant une pile vide.</p>\r\n<p>Note: utiliser <em>java.util.Stack&lt;E&gt;</em> est interdit!</p>\r\n<pre class=\"java\"><code>import java.util.EmptyStackException;\r\n\r\npublic interface Stack&lt;E&gt; {\r\n\r\n    public boolean empty();\r\n\r\n    public E peek() throws EmptyStackException;\r\n\r\n    public E pop() throws EmptyStackException;\r\n\r\n    public void push(E item);\r\n\r\n}</code></pre>\r\n<pre class=\"java\"><code>import java.util.EmptyStackException;\r\n\r\npublic class MyStack&lt;E&gt; implements Stack&lt;E&gt; {\r\n\r\n    private Node&lt;E&gt; top;        // the node on the top of the stack\r\n    private int size;        // size of the stack\r\n\r\n    // helper linked list class\r\n    private class Node&lt;E&gt; {\r\n        private E item;\r\n        private Node&lt;E&gt; next;\r\n\r\n        public Node(E element, Node&lt;E&gt; next) {\r\n            this.item = element;\r\n            this.next = next;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Tests if this stack is empty\r\n    */\r\n    @Override\r\n    public boolean empty() {\r\n        // TODO STUDENT: Implement empty method\r\n    }\r\n\r\n    /**\r\n    * Looks at the object at the top of this stack\r\n    * without removing it from the stack\r\n    */\r\n    @Override\r\n    public E peek() throws EmptyStackException {\r\n        // TODO STUDENT: Implement peek method\r\n    }\r\n\r\n    /**\r\n    * Removes the object at the top of this stack\r\n    * and returns that object as the value of this function\r\n    */\r\n    @Override\r\n    public E pop() throws EmptyStackException {\r\n        // TODO STUDENT: Implement pop method\r\n    }\r\n\r\n    /**\r\n    * Pushes an item onto the top of this stack\r\n    * @param item the item to append\r\n    */\r\n    @Override\r\n    public void push(E item) {\r\n        // TODO STUDENT: Implement push method\r\n\r\n    }\r\n}</code></pre>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/m1stack/LSINF1121_PART1_Stack.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Simon Hardy",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/m1stack",
            "archive_properties": {
                "folders": [
                    "m1stack"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Write Unit tests Stack (Implem)",
            "description": "<p>Rappelez-vous de l'interface Stack :</p>\r\n<pre class=\"java\"><code>import java.util.EmptyStackException;\r\n\r\npublic interface Stack&lt;E&gt; {\r\n\r\n    public boolean empty();\r\n\r\n    public E peek() throws EmptyStackException;\r\n\r\n    public E pop() throws EmptyStackException;\r\n\r\n    public void push(E item);\r\n\r\n}</code></pre>\r\n<p>Il vous est demandé d'écrire des tests unitaire (en utilisant JUnit) afin de vérifier si une implémentation particulière de cette interface est correcte.</p>\r\n<p>Voici un modèle simple que vous pouvez utiliser pour écrire vos tests (vous pouvez utiliser d'autres types que des String, bien sûr !) :</p>\r\n<pre class=\"java\"><code>import org.junit.Test;\r\nimport static org.junit.Assert.assertEquals;\r\n\r\npublic class StackTests {\r\n\r\n    @Test\r\n    public void firstTest() {\r\n        Stack&lt;Integer&gt; stack = new MyStack&lt;Integer&gt;();\r\n        stack.push(1);\r\n        assertEquals(new Integer(1), stack.pop());\r\n    }\r\n\r\n    @Test\r\n    public void secondTest() {\r\n        // ... TODO ...\r\n    }\r\n\r\n}</code></pre>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/m1stacktests/LSINF1121_PART1_Stack.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Simon Hardy",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/m1stacktests",
            "archive_properties": {
                "folders": [
                    "m1stacktests"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "QCM",
            "description": "\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Antoine Cailliau",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                },
                {
                    "category": 2,
                    "text": "Mission 2"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/m2bilanqcm",
            "archive_properties": {
                "folders": [
                    "m2bilanqcm"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Median",
            "description": "<p>Nous vous donnons l'API d'une classe Vector permettant d'accéder, modifier et interchanger deux élements en temps constant. Votre tâche est d'implémenter une méthode permettant de calculer la médiane d'un Vecteur.</p>\r\n<pre class=\"java\"><code>public interface Vector {\r\n    // taille du vecteur\r\n    public int size();\r\n    // mets la valeur v à l&#39;indice i du vecteur\r\n    public void set(int i, int v);\r\n    // renvoie la valeur à l&#39;indice i du vecteur\r\n    public int get(int i);\r\n    // échange les valeurs aux positions i et j\r\n    public void swap(int i, int j);\r\n\r\n}</code></pre>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/median/project.zip\">Un projet Eclipse contenant des tests basiques vous est fourni en cliquant sur ce lien.</a></p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "category": 2,
                    "text": "Mission 2"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/median",
            "archive_properties": {
                "folders": [
                    "median"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Circular linkedlist (Implem)",
            "description": "<p>On s’intéresse à l'implémentation d'une <code>liste simplement chaînée circulaire</code>, c’est-à-dire une liste pour laquelle la dernière position de la liste fait référence, comme position suivante, à la première position de la liste.</p>\r\n<p><img src=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/p1circularlinkedlist/CircularLinkedList.png\" alt=\"image\" /></p>\r\n<p>L’ajout d’un nouvel élément dans la file (méthode <code>enqueue</code>) se fait en fin de liste et le retrait (méthode <code>remove</code>) se fait a un <span class=\"title-ref\">index</span> particulier de la liste. Une (seule) référence sur la fin de la liste (<code>last</code>) est nécessaire pour effectuer toutes les opérations sur cette file.</p>\r\n<p>Il vous est donc demander d'implémenter cette liste simplement chaînée circulaire à partir de la classe <code>CircularLinkedList.java</code> où vous devez completer (<em>TODO STUDENT</em>) les méthodes d'ajout (<code>enqueue</code>) et de retrait (<code>remove</code>) ainsi qu'un itérateur (<code>ListIterator</code>) qui permet de parcourir la liste en FIFO. <em>Attention:</em> un itérateur ne peut être modifié au cours de son utilisation.</p>\r\n<pre class=\"java\"><code>package student;\r\n\r\nimport java.util.ConcurrentModificationException;\r\nimport java.util.Iterator;\r\nimport java.util.NoSuchElementException;\r\n\r\npublic class CircularLinkedList&lt;Item&gt; implements Iterable&lt;Item&gt; {\r\n private long nOp = 0; // count the number of operations\r\n private int n;          // size of the stack\r\n private Node  last;   // trailer of the list\r\n\r\n // helper linked list class\r\n private class Node {\r\n     private Item item;\r\n     private Node next;\r\n }\r\n\r\n public CircularLinkedList() {\r\n     last = null;\r\n     n = 0;\r\n }\r\n\r\n public boolean isEmpty() { return n == 0; }\r\n\r\n public int size() { return n; }\r\n\r\n private long nOp() { return nOp; }\r\n\r\n /**\r\n  * Append an item at the end of the list\r\n  * @param item the item to append\r\n  */\r\n public void enqueue(Item item) {\r\n     // TODO STUDENT: Implement add method\r\n }\r\n\r\n /**\r\n  * Removes the element at the specified position in this list.\r\n  * Shifts any subsequent elements to the left (subtracts one from their indices).\r\n  * Returns the element that was removed from the list.\r\n  */\r\n public Item remove(int index) {\r\n     // TODO STUDENT: Implement remove method\r\n }\r\n\r\n /**\r\n  * Returns an iterator that iterates through the items in FIFO order.\r\n  * @return an iterator that iterates through the items in FIFO order.\r\n  */\r\n public Iterator&lt;Item&gt; iterator() {\r\n     return new ListIterator();\r\n }\r\n\r\n /**\r\n  * Implementation of an iterator that iterates through the items in FIFO order.\r\n  *\r\n  */\r\n private class ListIterator implements Iterator&lt;Item&gt; {\r\n     // TODO STUDDENT: Implement the ListIterator\r\n }\r\n\r\n}</code></pre>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/p1circularlinkedlist/LSINF1121CircularLinkedList.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/p1circularlinkedlist",
            "archive_properties": {
                "folders": [
                    "p1circularlinkedlist"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Circular linkedlist (Implem)",
            "description": "<p>On s’intéresse à l'implémentation d'une <code>liste simplement chaînée circulaire</code>, c’est-à-dire une liste pour laquelle la dernière position de la liste fait référence, comme position suivante, à la première position de la liste.</p>\r\n<figure>\r\n<img src=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part1CircularLinkedList/CircularLinkedList.png\" class=\"align-centeralign-center\" alt=\"\" />\r\n</figure>\r\n<p>L’ajout d’un nouvel élément dans la file (méthode <code>enqueue</code>) se fait en fin de liste et le retrait (méthode <code>remove</code>) se fait a un <span class=\"title-ref\">index</span> particulier de la liste. Une (seule) référence sur la fin de la liste (<code>last</code>) est nécessaire pour effectuer toutes les opérations sur cette file.</p>\r\n<p>Il vous est donc demander d'implémenter cette liste simplement chaînée circulaire à partir de la classe <code>CircularLinkedList.java</code> où vous devez completer (<em>TODO STUDENT</em>):</p>\r\n<ul>\r\n<li>la méthode d'ajout (<code>enqueue</code>);</li>\r\n<li>la méthode de retrait (<code>remove</code>) [L'exception <code>IndexOutOfBoundsException</code> est lancée quand la valeur de l'index n'est pas comprise en 0 et size()-1];</li>\r\n<li>l'itérateur (<code>ListIterator</code>) qui permet de parcourir la liste en FIFO.</li>\r\n</ul>\r\n<p><em>Attention:</em> L'itérateur devra lancer des exceptions dans les cas suivants:</p>\r\n<ul>\r\n<li>étant donnée que le <code>remove</code> est optionnel dans l'<a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html\">API</a> , l'iterateur devra juste lancer un <code>UnsupportedOperationException</code> en cas d'appel du <code>remove</code>;</li>\r\n<li>étant donnée qu'on ne peut modifier l'itérateur alors qu'on est en train d'itérer, l'iterateur devra lancer un <code>ConcurrentModificationException</code> dans ce cas dans le <code>next</code> et le <code>hasNest</code>;</li>\r\n<li>si le <code>next</code> est appelé alors qu'il n'y a plus de prochain élément, l'iterateur devra lancer un <code>NoSuchElementException</code>.</li>\r\n</ul>\r\n<pre class=\"java\"><code>import java.util.ConcurrentModificationException;\r\nimport java.util.Iterator;\r\nimport java.util.NoSuchElementException;\r\n\r\npublic class CircularLinkedList&lt;Item&gt; implements Iterable&lt;Item&gt; {\r\n private long nOp = 0; // count the number of operations\r\n private int n;          // size of the stack\r\n private Node  last;   // trailer of the list\r\n\r\n // helper linked list class\r\n private class Node {\r\n     private Item item;\r\n     private Node next;\r\n }\r\n\r\n public CircularLinkedList() {\r\n     last = null;\r\n     n = 0;\r\n }\r\n\r\n public boolean isEmpty() { return n == 0; }\r\n\r\n public int size() { return n; }\r\n\r\n private long nOp() { return nOp; }\r\n\r\n /**\r\n  * Append an item at the end of the list\r\n  * @param item the item to append\r\n  */\r\n public void enqueue(Item item) {\r\n     // TODO STUDENT: Implement add method\r\n }\r\n\r\n /**\r\n  * Removes the element at the specified position in this list.\r\n  * Shifts any subsequent elements to the left (subtracts one from their indices).\r\n  * Returns the element that was removed from the list.\r\n  */\r\n public Item remove(int index) {\r\n     // TODO STUDENT: Implement remove method\r\n }\r\n\r\n /**\r\n  * Returns an iterator that iterates through the items in FIFO order.\r\n  * @return an iterator that iterates through the items in FIFO order.\r\n  */\r\n public Iterator&lt;Item&gt; iterator() {\r\n     return new ListIterator();\r\n }\r\n\r\n /**\r\n  * Implementation of an iterator that iterates through the items in FIFO order.\r\n  *\r\n  */\r\n private class ListIterator implements Iterator&lt;Item&gt; {\r\n     // TODO STUDENT: Implement the ListIterator\r\n }\r\n\r\n}</code></pre>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part1CircularLinkedList/LSINF1121_PART1_CircularLinkedList.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part1CircularLinkedList",
            "archive_properties": {
                "folders": [
                    "Part1CircularLinkedList"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Global Warming (implem)",
            "description": "<h1 id=\"context\">Context</h1>\r\n<p>Supposons la matrice 5x5 suivante :</p>\r\n<pre class=\"java\"><code>int [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};</code></pre>\r\n<p>représentée dans le tableau ci-dessous :</p>\r\n<p><img src=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part2GlobalWarming/matrix.png\" class=\"align-center\" width=\"200\" alt=\"matrix example\" /></p>\r\n<p>Chaque entrée de la matrice représente une altitude. L'objectif est d'implémenter une classe <code>GlobalWarmingImpl</code> qui étend la méthode <span class=\"title-ref\">GlobalWarming</span> décrite ci-dessous.</p>\r\n<p>Compte tenu d'un niveau d'eau global, toutes les positions de la matrice ayant une valeur <em>&lt;=</em> au niveau d'eau sont inondées et donc peu sûres. Donc, en supposant que le niveau d'eau est de <em>3</em>, tous les points sûrs sont en vert (dans la représentation ci-dessus).</p>\r\n<p>La méthode que vous devez implémentez est <code>nbSafePoints</code></p>\r\n<ul>\r\n<li>le calcul du nombre de points de sécurité pour un niveau d'eau donné</li>\r\n</ul>\r\n<pre class=\"java\"><code>import java.util.List;\r\n\r\nabstract class GlobalWarming {\r\n\r\n\r\n    final int[][] altitude;\r\n\r\n    /**\r\n     * @param altitude is a n x n matrix of int values representing altitudes (positive or negative)\r\n     */\r\n    public GlobalWarming(int[][] altitude) {\r\n        this.altitude = altitude;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param waterLevel\r\n     * @return the number of entries in altitude matrix that would be above\r\n     *         the specified waterLevel.\r\n     *         Warning: this is not the waterLevel given in the constructor/\r\n     */\r\n    public abstract int nbSafePoints(int waterLevel);\r\n\r\n}</code></pre>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part2GlobalWarming/LSINF1121_PART2_GlobalWarming.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n<h1 id=\"exercices-préliminaires\">Exercices préliminaires</h1>\r\n<pre class=\"java\"><code>int [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};\r\nGlobalWarming gw = new MyGlobalWarming(tab);</code></pre>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part2GlobalWarming",
            "archive_properties": {
                "folders": [
                    "Part2GlobalWarming"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Median (implem)",
            "description": "<p>Nous vous donnons l'API d'une classe Vector permettant d'accéder, modifier et interchanger deux élements en temps constant. Votre tâche est d'implémenter une méthode permettant de calculer la médiane d'un Vecteur.</p>\r\n<pre class=\"java\"><code>public interface Vector {\r\n    // taille du vecteur\r\n    public int size();\r\n    // mets la valeur v à l&#39;indice i du vecteur\r\n    public void set(int i, int v);\r\n    // renvoie la valeur à l&#39;indice i du vecteur\r\n    public int get(int i);\r\n    // échange les valeurs aux positions i et j\r\n    public void swap(int i, int j);\r\n\r\n}</code></pre>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part2Median/LSINF1121_PART2_Median.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part2Median",
            "archive_properties": {
                "folders": [
                    "Part2Median"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Merge Sort (implem)",
            "description": "<p>Considérons l'algorithme de tri (descendant) <code>Merge Sort</code>.</p>\r\n<pre class=\"java\"><code>public class MergeSort {\r\n    /**\r\n     * Pre-conditions: a[lo..mid] and a[mid+1..hi] are sorted\r\n     * Post-conditions: a[lo..hi] is sorted\r\n     */\r\n    private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) {\r\n        for (int k = lo; k &lt;= hi; k++) {\r\n            aux[k] = a[k];\r\n        }\r\n\r\n        int i = lo;\r\n        int j = mid + 1;\r\n        for (int k = lo; k &lt;= hi; k++) {\r\n            if (i &gt; mid) {\r\n                a[k] = aux[j++];\r\n            } else if (j &gt; hi) {\r\n                a[k] = aux[i++];\r\n            } else if (aux[j].compareTo(aux[i]) &lt; 0) {\r\n                a[k] = aux[j++];\r\n            } else {\r\n                a[k] = aux[i++];\r\n            }\r\n        }\r\n    }\r\n\r\n    // Mergesort a[lo..hi] using auxiliary array aux[lo..hi]\r\n    private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) {\r\n        // TODO\r\n    }\r\n\r\n    /**\r\n     * Rearranges the array in ascending order, using the natural order\r\n     */\r\n    public static void sort(Comparable[] a) {\r\n        // TODO\r\n    }\r\n}</code></pre>\r\n<p><strong>Note:</strong> Les questions suivantes vous demanderont d'implémenter la fonction left out. Vous n'avez pas besoin de mettre les accolades (<code>{ }</code>) entourant le corps de la fonction dans votre réponse.</p>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part2MergeSort/LSINF1121_PART2_MergeSort.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part2MergeSort",
            "archive_properties": {
                "folders": [
                    "Part2MergeSort"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "QCM",
            "description": "\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Antoine Cailliau",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part2QCM",
            "archive_properties": {
                "folders": [
                    "Part2QCM"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Union Intervals (implem)",
            "description": "<p>Etant donné un tableau d'intervalles (fermés), Il vous est demandé d'implémenter l'opération <code>union</code>. Cette opération retournera le tableau minimal d'intervalles triés couvrant exactement l'union des points couverts par les intervalles d'entrée.</p>\r\n<p>Par exemple, l'union des intervalles <em>[7,9],[5,8],[2,4]</em> est <em>[2,4],[5,9]</em>.</p>\r\n<p>La classe <code>Interval</code> permetant de stocker les intervalles vous est fourni et se présente comme suit (vous pouvez l'utiliser directement dans votre code):</p>\r\n<pre class=\"java\"><code>public class Interval implements Comparable&lt;Interval&gt; {\r\n\r\n    final int min, max;\r\n    public Interval(int min, int max) {\r\n        assert(min &lt;= max);\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        return ((Interval) obj).min == min &amp;&amp; ((Interval) obj).max == max;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return &quot;[&quot;+min+&quot;,&quot;+max+&quot;]&quot;;\r\n    }\r\n\r\n    @Override\r\n    public int compareTo(Interval o) {\r\n        if (min &lt; o.min) return -1;\r\n        else if (min == o.min) return max - o.max;\r\n        else return 1;\r\n    }\r\n}</code></pre>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part2UnionIntervals/LSINF1121_PART2_UnionIntervals.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n<p>Nous vous conseillons de le télécharger d'implémenter/tester avant de soumettre ce qui vous est demandé.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part2UnionIntervals",
            "archive_properties": {
                "folders": [
                    "Part2UnionIntervals"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Binary Search Tree (implem)",
            "description": "<p>Etant donné un arbre de recherche binaire, dont les noeuds implémentent l'interface Node:</p>\r\n<pre class=\"java\"><code>interface Node {\r\n    /**\r\n      * @return the value contained in this node\r\n      */\r\n    int getValue();\r\n\r\n    /**\r\n     * @return the node on the left (whose value is &lt; than the current value)\r\n     * if it exists, null if not\r\n     */\r\n    Node getLeft();\r\n\r\n    /**\r\n      * @return the node on the right (whose value is &gt; than the current value)\r\n      * if it exists, null if not\r\n      */\r\n    Node getRight();\r\n}</code></pre>\r\n<p>L'on vous demande de fournir le <strong>corps</strong> de la fonction <em>ceil</em>, qui trouve dans l'arbre le plus petit élément plus grand ou égal à <span class=\"title-ref\">value</span> (donc soit l'élément lui-même soit l'élément situé directement après par ordre de grandeur). Si un tel élément n'existe pas, elle doit retourner <span class=\"title-ref\">null</span>.</p>\r\n<p>Par exemple si on a ce BST,</p>\r\n<figure>\r\n<img src=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART3Bst/bst.png\" class=\"align-centeralign-center\" alt=\"\" />\r\n</figure>\r\n<ul>\r\n<li>ceil(11) nous renverra 11,</li>\r\n<li>ceil(4) nous renverra 8,</li>\r\n<li>et ceil(21) nous renverra null.</li>\r\n</ul>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART3Bst/LSINF1121_PART3_BinarySearchTree.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Guillaume Derval",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "Simon Teugels",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART3Bst",
            "archive_properties": {
                "folders": [
                    "PART3Bst"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Binary Search Tree Iterator (implem)",
            "description": "<p>On s’intéresse à l'implémentation d'un itérateur (<code>BSTIterator</code>) qui permet de traverser un <code>Binary Search Tree</code> dans l'ordre croissant (<em>In-order transversal</em>).</p>\r\n<p>Par exemple si on a ce BST,</p>\r\n<figure>\r\n<img src=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART3OrderedBstIterator/bst.png\" class=\"align-centeralign-center\" alt=\"\" />\r\n</figure>\r\n<p>on veut le parcourir comme suit <em>[3,8,9,11,12,14,15,18,20]</em></p>\r\n<p><em>Attention:</em> L'itérateur devra lancer des exceptions dans les cas suivants:</p>\r\n<ul>\r\n<li>étant donnée qu'on ne peut modifier l'itérateur alors qu'on est en train d'itérer, l'iterateur devra lancer un <code>ConcurrentModificationException</code> dans ce cas dans le <code>next</code> et le <code>hasNest</code>;</li>\r\n<li>si le <code>next</code> est appelé alors qu'il n'y a plus de prochain élément, l'iterateur devra lancer un <code>NoSuchElementException</code>.</li>\r\n</ul>\r\n<pre class=\"java\"><code>import java.util.ConcurrentModificationException;\r\nimport java.util.Iterator;\r\nimport java.util.NoSuchElementException;\r\nimport java.util.Stack;\r\n\r\n   public class BST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; implements Iterable&lt;Key&gt; {\r\n    private Node root;             // root of BST\r\n\r\n    private class Node {\r\n        private final Key key;       // sorted by key\r\n        private Value val;           // associated data\r\n        private Node left, right;    // left and right subtrees\r\n        private int size;            // number of nodes in subtree\r\n\r\n        public Node(Key key, Value val, int size) {\r\n            this.key = key;\r\n            this.val = val;\r\n            this.size = size;\r\n        }\r\n\r\n        public int getSize() {\r\n            return size;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes an empty symbol table.\r\n     */\r\n    public BST() {}\r\n\r\n    /**\r\n     * Returns true if this symbol table is empty.\r\n     * @return {@code true} if this symbol table is empty; {@code false} otherwise\r\n     */\r\n    public boolean isEmpty() {\r\n        return size() == 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of key-value pairs in this symbol table.\r\n     * @return the number of key-value pairs in this symbol table\r\n     */\r\n    public int size() {\r\n        return size(root);\r\n    }\r\n\r\n    // return number of key-value pairs in BST rooted at x\r\n    private int size(Node x) {\r\n        if (x == null) return 0;\r\n        else return x.size;\r\n    }\r\n\r\n    public void inOrder(){\r\n        inOrder(root);\r\n    }\r\n    private void inOrder(Node x) {\r\n        if (x == null) return;\r\n\r\n        inOrder(x.left);\r\n        System.out.println(x.key+&quot;=&gt;&quot;+x.val);\r\n        inOrder(x.right);\r\n    }\r\n\r\n    /**\r\n     * Returns the value associated with the given key.\r\n     *\r\n     * @param  key the key\r\n     * @return the value associated with the given key if the key is in the symbol table\r\n     *         and {@code null} if the key is not in the symbol table\r\n     */\r\n    public Value get(Key key) {\r\n        return get(root, key);\r\n    }\r\n\r\n    private Value get(Node x, Key key) {\r\n        if (x == null) return null;\r\n        int cmp = key.compareTo(x.key);\r\n        if      (cmp &lt; 0) return get(x.left, key);\r\n        else if (cmp &gt; 0) return get(x.right, key);\r\n        else              return x.val;\r\n    }\r\n\r\n    /**\r\n     * Search for key, update value if key is found. Grow table if key is new.\r\n     *\r\n     * @param  key the key\r\n     * @param  val the value\r\n     */\r\n    public void put(Key key, Value val) {\r\n        root = put(root, key, val);\r\n    }\r\n    private Node put(Node x, Key key, Value val) {\r\n        if (x == null) return new Node(key, val, 1);\r\n        int cmp = key.compareTo(x.key);\r\n        if      (cmp &lt; 0) x.left  = put(x.left,  key, val);\r\n        else if (cmp &gt; 0) x.right = put(x.right, key, val);\r\n        else              x.val   = val;\r\n        x.size = 1 + size(x.left) + size(x.right);\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns an iterator that iterates through the keys in Incresing order\r\n     * (In-Order transversal).\r\n     * @return an iterator that iterates through the items in FIFO order.\r\n     */\r\n    @Override\r\n    public Iterator&lt;Key&gt; iterator() {\r\n        return new BSTIterator();\r\n    }\r\n\r\n        /**\r\n  * Implementation of an iterator that iterates through the keys of BST in incresing order (In-order transversal).\r\n  *\r\n  */\r\n    private class BSTIterator implements Iterator&lt;Key&gt; {\r\n\r\n        // TODO STUDDENT: Implement the BSTIterator\r\n\r\n    }\r\n}</code></pre>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART3OrderedBstIterator/LSINF1121_PART3_OrderedBstIterator.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART3OrderedBstIterator",
            "archive_properties": {
                "folders": [
                    "PART3OrderedBstIterator"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "QCM",
            "description": "\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Antoine Cailliau",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART3Qcm",
            "archive_properties": {
                "folders": [
                    "PART3Qcm"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "QCM Binary Trees",
            "description": "<p>Consider this ordered binary tree:</p>\r\n<figure>\r\n<img src=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART3QcmBt/bt.png\" class=\"align-centeralign-center\" alt=\"\" />\r\n</figure>\r\n<p>We traverse this tree and we print the value of each node we visit it.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART3QcmBt",
            "archive_properties": {
                "folders": [
                    "PART3QcmBt"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Red Black Tree",
            "description": "<p>Prenons l'exemple d'un <code>Red-Black Tree</code> vide dans lequel on ajoute progressivement des chiffres.</p>\r\n<p>Les questions suivantes vous demanderont d'écrire une représentation du <code>Red-Black Tree</code> au fur et à mesure que nous y ajouterons des objets.</p>\r\n<p>Écrivez la réponse comme si vous lisiez le <code>Red-Black Tree</code> de gauche à droite et de haut en bas (en ignorant les blancs possibles). Par exemple, si votre réponse est :</p>\r\n<figure>\r\n<img src=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART3Rbt/rbt.png\" class=\"align-centeralign-center\" alt=\"\" />\r\n</figure>\r\n<p>Vous écririez:</p>\r\n<pre><code>6 24 7 1 3 5 9</code></pre>\r\n<p>Remarquez comment le nœud 2-3 composé de <code>2</code>et <code>4</code> est écrit d'une manière fusionnée (<code>24</code>).</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART3Rbt",
            "archive_properties": {
                "folders": [
                    "PART3Rbt"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Write Unit tests Red Black Tree",
            "description": "<p>Il vous est demandé d'écrire des tests unitaire (en utilisant JUnit) afin de vérifier si une implémentation particulière d'un <code>Red-Black Tree</code> est correcte.</p>\r\n<p>Voici un modèle simple que vous pouvez utiliser pour écrire vos tests :</p>\r\n<blockquote>\r\n<pre class=\"java\"><code>import org.junit.Test;\r\nimport static org.junit.Assert.assertEquals;\r\n\r\npublic class RedBlackTests {\r\n\r\n    @Test\r\n    public void firstTest() {\r\n        // ... TODO ...\r\n    }\r\n\r\n    @Test\r\n    public void secondTest() {\r\n        // ... TODO ...\r\n    }\r\n\r\n}</code></pre>\r\n</blockquote>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART3WriteUnittestsRedBlackTree/LSINF1121_PART3_UnitTestsRedBlackTree.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Simon Teugels",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART3WriteUnittestsRedBlackTree",
            "archive_properties": {
                "folders": [
                    "PART3WriteUnittestsRedBlackTree"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Incremental Hash (implem)",
            "description": "<p>La fonction de Hash calculée sur le sous tableau <span class=\"math inline\"><em>t</em>[<em>f</em><em>r</em><em>o</em><em>m</em>, ..., <em>f</em><em>r</em><em>o</em><em>m</em> + <em>M</em> − 1]</span> est calculée comme suit:</p>\r\n<p><span class=\"math inline\">$hash([from,...,from+M-1])= \\left( \\sum_{i=0}^{M-1} t[from+i] \\cdot R^{(M-1-i)}\\right)\\%Q$</span></p>\r\n<p>Le code pour calculer cette fonction de hash vous est donné. Nous vous demandons de calculer <span class=\"math inline\"><em>h</em><em>a</em><em>s</em><em>h</em>([<em>f</em><em>r</em><em>o</em><em>m</em>, ..., <em>f</em><em>r</em><em>o</em><em>m</em> + <em>M</em> − 1])</span> au départ de <span class=\"math inline\"><em>h</em><em>a</em><em>s</em><em>h</em>([<em>f</em><em>r</em><em>o</em><em>m</em> − 1, ..., <em>f</em><em>r</em><em>o</em><em>m</em> + <em>M</em> − 2])</span> en O(1).</p>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part4IncrementalHash/LSINF1121_PART4_IncrementalHash.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part4IncrementalHash",
            "archive_properties": {
                "folders": [
                    "Part4IncrementalHash"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "QCM Hashing",
            "description": "<p>Etant donné une fonction de hachage:</p>\r\n<p><span class=\"math inline\">$h(\\left[v_0 \\cdots v_{n-1} \\right]) = \\sum\\limits_{i=0}^{n-1} v_i R^{(n-i-1)} \\% M$</span></p>\r\n<p>dans laquelle <span class=\"math inline\">[<em>v</em><sub>0</sub>⋯<em>v</em><sub><em>n</em> − 1</sub>]</span> dénote un vecteur de bit et <span class=\"math inline\"><em>R</em></span> et <span class=\"math inline\"><em>M</em></span> sont des facteurs constants.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "xgillard",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "john Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part4QcmHashing",
            "archive_properties": {
                "folders": [
                    "Part4QcmHashing"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "QCM Rabin Karp",
            "description": "<p>A la page 777 du livre \"Algorithms\" 4th edition, on vous propose l'implémentation suivante de l'algorithme de Rabin Karp.</p>\r\n<pre class=\"java\"><code>public class RabinKarp {\r\n  private String pat;      // the pattern  // needed only for Las Vegas\r\n  private long patHash;    // pattern hash value\r\n  private int m;           // pattern length\r\n  private long q;          // a large prime, small enough to avoid long overflow\r\n  private int R;           // radix\r\n  private long RM;         // R^(M-1) % Q\r\n\r\n  public RabinKarp(String pat) {\r\n      this.pat = pat;      // save pattern (needed only for Las Vegas)\r\n      R = 256;\r\n      m = pat.length();\r\n      q = longRandomPrime();\r\n\r\n      // precompute R^(m-1) % q for use in removing leading digit\r\n      RM = 1;\r\n      for (int i = 1; i &lt;= m-1; i++)\r\n          RM = (R * RM) % q;\r\n      patHash = hash(pat, m);\r\n  }\r\n\r\n  // Compute hash for key[0..m-1].\r\n  private long hash(String key, int m) {\r\n      long h = 0;\r\n      for (int j = 0; j &lt; m; j++)\r\n          h = (R * h + key.charAt(j)) % q;\r\n      return h;\r\n  }\r\n\r\n  // Monte Carlo\r\n  private boolean check(int i) {\r\n      return true;\r\n  }\r\n\r\n  // Returns the index of the first occurrrence of the pattern string in the text string.\r\n  public int search(String txt) {\r\n      int n = txt.length();\r\n      if (n &lt; m) return n;\r\n      long txtHash = hash(txt, m);\r\n\r\n      // check for match at offset 0\r\n      if ((patHash == txtHash) &amp;&amp; check(txt, 0))\r\n          return 0;\r\n\r\n      // check for hash match; if hash match, check for exact match\r\n      for (int i = m; i &lt; n; i++) {\r\n          // Remove leading digit, add trailing digit, check for match.\r\n          txtHash = (txtHash + q - RM*txt.charAt(i-m) % q) % q;\r\n          txtHash = (txtHash*R + txt.charAt(i)) % q;\r\n\r\n          // match\r\n          int offset = i - m + 1;\r\n          if ((patHash == txtHash) &amp;&amp; check(txt, offset))\r\n              return offset;\r\n      }\r\n\r\n      // no match\r\n      return n;\r\n  }\r\n\r\n\r\n  // a random 31-bit prime\r\n  private static long longRandomPrime() {\r\n      BigInteger prime = BigInteger.probablePrime(31, new Random());\r\n      return prime.longValue();\r\n  }\r\n\r\n}</code></pre>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Xavier Gillard",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part4QcmRk",
            "archive_properties": {
                "folders": [
                    "Part4QcmRk"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Rabin Karp of k patterns (implem)",
            "description": "<p>On s'intéresse à l'algorithme de Rabin-Karp. On voudrait le modifier quelque peu pour déterminer si un mot parmi une liste (tous les mots sont de même longueur) est présent dans le texte.</p>\r\n<p>Pour cela, vous devez modifier l'algorithme de Rabin-Karp qui se trouve ci-dessous (Page 777 du livre).</p>\r\n<p>Plus précisément, on vous demande de modifier cette classe de manière à avoir un constructeur de la forme:</p>\r\n<pre class=\"java\"><code>public RabinKarp(String[] pat)</code></pre>\r\n<p>De plus la fonction <code>search</code> doit retourner l'indice du début du premier mot (parmi le tableau <code>pat</code>) trouvé dans le texte ou la taille du texte si aucun mot n'aparait dans le texte.</p>\r\n<p>Exemple: Si txt = “Here find interresting exercise for Rabin Karp” et pat={“have”, “find”, “Karp”} la fonction <code>search</code> doit renvoyer 5 car le mot \"find\" présent dans le texte et dans la liste commence à l'indice 5.</p>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part4RabinKarp/LSINF1121_PART4_RabinKarp.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part4RabinKarp",
            "archive_properties": {
                "folders": [
                    "Part4RabinKarp"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Binary Heap Push (implem)",
            "description": "<p>Dans cette tâche on vous propose d'implémenter la fonction d'insertion <code>push()</code> d'un heap binaire.</p>\r\n<blockquote>\r\n<p>La fonction push agit sur un tableau, nommé <code>contenu</code>, qui représente un arbre, selon la méthode vue au cours: le noeud n°i de l'arbre a pour enfant les indices 2*i et 2*i+1.</p>\r\n</blockquote>\r\n<p>il faut noter que dans le livre à la page 318 a été proposée le <code>MaxPQ</code> mais ici nous vous proposons de plutot réfléchir aux changements à apporter à ce code pour implémenter un <code>MinPQ</code> notamment à la fonction d'insertion.</p>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART5BinaryHeapPush/LSINF1121_PART5_BinaryHeapPush.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART5BinaryHeapPush",
            "archive_properties": {
                "folders": [
                    "PART5BinaryHeapPush"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Global Warming (implem)",
            "description": "<h1 id=\"context\">Context</h1>\r\n<p>Supposons la matrice 5x5 suivante:</p>\r\n<pre class=\"java\"><code>int [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};</code></pre>\r\n<p>représentée dans le tableau ci-dessous :</p>\r\n<p><img src=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part5GlobalWarming/matrix.png\" class=\"align-center\" width=\"200\" alt=\"matrix example\" /></p>\r\n<p>Chaque entrée de la matrice représente une altitude. L'objectif est d'implémenter une classe <span class=\"title-ref\">GlobalWarmingImpl</span> qui implémente toutes les méthodes décrites dans <span class=\"title-ref\">GlobalWarming</span> données ci-dessous.</p>\r\n<p>Un niveau d'eau global spécifié dans le constructeur modélise le fait que toutes les positions de la matrice avec une valeur &lt;= le niveau d'eau sont inondées (sous l'eau) et donc dangereuses. Dans l'exemple ci-dessus, le niveau d'eau est de 3, tous les points sûrs sont en vert.</p>\r\n<p>Les méthodes que vous devez implémenter sont les suivantes</p>\r\n<ul>\r\n<li>le nombre d'îles</li>\r\n<li>un test pour vérifier si deux positions sont sur la même île</li>\r\n</ul>\r\n<p>nous supposons que les points sont <strong>uniquement connectés verticalement ou horizontalement</strong>.</p>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part5GlobalWarming/LSINF1121_PART5_GlobalWarming.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n<pre class=\"java\"><code>import java.util.List;\r\n\r\nabstract class GlobalWarming {\r\n\r\n    /**\r\n     * A class to represent the coordinates on the altitude matrix\r\n     */\r\n    public static class Point {\r\n\r\n        final int x, y;\r\n\r\n        Point(int x, int y) {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n\r\n        @Override\r\n        public boolean equals(Object obj) {\r\n            Point p = (Point) obj;\r\n            return p.x == x &amp;&amp; p.y == y;\r\n        }\r\n    }\r\n\r\n    final int[][] altitude;\r\n    final int waterLevel;\r\n\r\n\r\n    /**\r\n     * In the following, we assume that the points are connected to\r\n     * horizontal or vertical neighbors but not to the diagonal ones\r\n     * @param altitude is a n x n matrix of int values representing altitudes (positive or negative)\r\n     * @param waterLevel is the water level, every entry &lt;= waterLevel is flooded\r\n     */\r\n    public GlobalWarming(int[][] altitude, int waterLevel) {\r\n        this.altitude = altitude;\r\n        this.waterLevel = waterLevel;\r\n    }\r\n\r\n\r\n    /**\r\n     * An island is a connected components of safe points wrt to waterLevel\r\n     * @return the number of islands\r\n     */\r\n    public abstract int nbIslands();\r\n\r\n    /**\r\n     *\r\n     * @param p1 a point with valid coordinates on altitude matrix\r\n     * @param p2 a point with valid coordinates on altitude matrix\r\n     * @return true if p1 and p2 are on the same island, that is both p1 and p2 are safe wrt waterLevel\r\n     *        and there exists a path (vertical/horizontal moves) from p1 to p2 using only safe positions\r\n     */\r\n    public abstract boolean onSameIsland(Point p1, Point p2);\r\n\r\n\r\n}</code></pre>\r\n<h1 id=\"preliminary-exercises\">Preliminary exercises</h1>\r\n<pre class=\"java\"><code>int [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};\r\nGlobalWarming gw = new MyGlobalWarming(tab,3);</code></pre>\r\n<p><img src=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part5GlobalWarming/matrix.png\" class=\"align-center\" width=\"200\" alt=\"matrix example\" /></p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part5GlobalWarming",
            "archive_properties": {
                "folders": [
                    "Part5GlobalWarming"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Heap",
            "description": "<p>Considérons la structure de données <code>Heap</code> dans laquelle on ajoute progressivement des nombres.</p>\r\n<p>Les questions suivantes vous demanderont d'écrire une représentation du <code>Heap</code> au fur et à mesure que nous y ajoutons des objets. Vous devez écrire le <code>Heap</code> comme s'il était stocké dans un tableau. Par exemple, si votre réponse est :</p>\r\n<pre><code>9\r\n/ \\\r\n5   8\r\n/ \\\r\n4   3</code></pre>\r\n<p>Vous devriez écrire:</p>\r\n<pre><code>9 5 8 4 3</code></pre>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part5Heap",
            "archive_properties": {
                "folders": [
                    "Part5Heap"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Huffman (implem)",
            "description": "<p>Vous devez calculer un arbre de Huffman au départ de la fréquence donnée pour chacune des R lettres (characters).</p>\r\n<p>Pour rappel, dans un arbre de Huffman nous avons que <em>la somme de la fréquence associée à chaque feuille multipliée par la profondeur de celle-ci est minimale</em>.</p>\r\n<p>Par exemple, étant donné les fréquences suivantes:</p>\r\n<p><img src=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part5Huffman/huffmanin.png\" class=\"align-center\" width=\"500\" alt=\"Input frequencies\" /></p>\r\n<p>un arbre de Huffman pourrait être:</p>\r\n<p><img src=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part5Huffman/huffmanout.png\" class=\"align-center\" width=\"500\" alt=\"Huffman tree\" /></p>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part5Huffman/LSINF1121_PART5_Huffman.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part5Huffman",
            "archive_properties": {
                "folders": [
                    "Part5Huffman"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Union find",
            "description": "<p>Considérons un graphe composé de 10 nœuds disjoints (numérotés de 0 à 9). Nous utilisons une structure de données union-find pour représenter ce graphe. Dans un premier temps, chaque nœud est contenu dans une partition qui porte son nom. Ainsi, la représentation du graphique dans le tableau <code>id[]</code> est :</p>\r\n<pre><code>0 1 2 3 4 5 6 7 8 9</code></pre>\r\n<p>Les questions suivantes vous demanderont de donner la représentation du graphe après avoir utilisé l'algorithme <strong>quick-find</strong> pour ajouter une arête entre 2 noeuds. Vous devez donner cette représentation de la même manière qu'elle a été donnée ci-dessus.</p>\r\n<p><strong>Note:</strong> Lorsque nous joignons <code>p-q</code> avec l'algorithme quick-find, la convention est de changer <code>id[p]</code> (et éventuellement d'autres entrées) mais pas <code>id[q]</code>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part5UnionFind",
            "archive_properties": {
                "folders": [
                    "Part5UnionFind"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "PART 6  - Breadth First Paths (implem)",
            "description": "<p>Considérez cette classe, <code>BreadthFirstShortestPaths</code>, qui calcule le chemin le plus court entre plusieurs sources de nœuds et n'importe quel nœud dans un graphe non dirigé en utilisant un parcours BFS.</p>\r\n<pre class=\"java\"><code>// TODO\r\n\r\npublic class BreadthFirstShortestPaths {\r\n\r\n    private static final int INFINITY = Integer.MAX_VALUE;\r\n    private boolean[] marked; // marked[v] = is there an s-v path\r\n    private int[] distTo;     // distTo[v] = number of edges shortest s-v path\r\n\r\n    /**\r\n     * Computes the shortest path between any\r\n     * one of the sources and very other vertex\r\n     * @param G the graph\r\n     * @param sources the source vertices\r\n     */\r\n     public BreadthFirstShortestPaths(Graph G, Iterable&lt;Integer&gt; sources) {\r\n         marked = new boolean[G.V()];\r\n         distTo = new int[G.V()];\r\n         for (int v = 0;v &lt; G.V();v++) {\r\n             distTo[v] = INFINITY;\r\n         }\r\n         bfs(G, sources);\r\n     }\r\n\r\n     // Breadth-first search from multiple sources\r\n     private void bfs(Graph G, Iterable&lt;Integer&gt; sources) {\r\n         // TODO\r\n     }\r\n\r\n     /**\r\n      * Is there a path between (at least one of) the sources and vertex v?\r\n      * @param v the vertex\r\n      * @return true if there is a path, and false otherwise\r\n      */\r\n     public boolean hasPathTo(int v) {\r\n         // TODO\r\n     }\r\n\r\n     /**\r\n      * Returns the number of edges in a shortest path\r\n      * between one of the sources and vertex v?\r\n      * @param v the vertex\r\n      * @return the number of edges in a shortest path\r\n      */\r\n     public int distTo(int v) {\r\n         // TODO\r\n     }\r\n}</code></pre>\r\n<p>La classe <code>Graph</code> est déjà implémentée et la voici :</p>\r\n<pre class=\"java\"><code>public class Graph {\r\n    // @return the number of vertices\r\n    public int V() { }\r\n\r\n    // @return the number of edges\r\n    public int E() { }\r\n\r\n    // Add edge v-w to this graph\r\n    public void addEdge(int v, int w) { }\r\n\r\n    // @return the vertices adjacent to v\r\n    public Iterable&lt;Integer&gt; adj(int v) { }\r\n\r\n    // @return a string representation\r\n    public String toString() { }\r\n}</code></pre>\r\n<p><strong>Note:</strong> Les questions suivantes vous demanderont d'implémenter tous les <code>TODO</code> de la classe <code>BreadthFirstShortestPaths</code>. Vous n'avez pas besoin de mettre les accolades (<code>{ }</code>) entourant le corps de la fonction dans votre réponse.</p>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6BreadthFirstPaths/LSINF1121_PART6_BreadthFirstShortestPaths.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6BreadthFirstPaths",
            "archive_properties": {
                "folders": [
                    "Part6BreadthFirstPaths"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Connected Components (implem)",
            "description": "<p>Il vous ait demandé d'implémenter la classe des composants connexes <code>ConnectedComponent</code> étant donnée un graphe. La classe <a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6ConnectedComponents/javadoc.zip\">Graph</a> disponible dans le code est celle de l'API de la classe <a href=\"https://docs.oracle.com/javase/8/docs/api/\">Java</a>.</p>\r\n<pre class=\"java\"><code>public class ConnectedComponents {\r\n  /**\r\n   * @return the number of connected components in g\r\n   */\r\n  public static int numberOfConnectedComponents(Graph g) {\r\n    // TODO\r\n    return 0;\r\n  }\r\n}</code></pre>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6ConnectedComponents/LSINF1121_PART6_ConnectedComponents.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "psc",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6ConnectedComponents",
            "archive_properties": {
                "folders": [
                    "Part6ConnectedComponents"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Depth First Paths (implem)",
            "description": "<p>Considérez cette classe, <code>DepthFirstPaths</code>, qui calcule les chemins vers n'importe quel noeud connecté à partir d'un noeud source <code>s</code> dans un graphe non dirigé en utilisant un parcours DFS.</p>\r\n<pre class=\"java\"><code>// TODO\r\n\r\npublic class DepthFirstPaths {\r\n    private boolean[] marked; // marked[v] = is there an s-v path?\r\n    private int[] edgeTo;     // edgeTo[v] = last edge on s-v path\r\n    private final int s;\r\n\r\n    /**\r\n     * Computes a path between s and every other vertex in graph G\r\n     * @param G the graph\r\n     * @param s the source vertex\r\n     */\r\n     public DepthFirstPaths(Graph G, int s) {\r\n         this.s = s;\r\n         edgeTo = new int[G.V()];\r\n         marked = new boolean[G.V()];\r\n         dfs(G, s);\r\n     }\r\n\r\n     // Depth first search from v\r\n     private void dfs(Graph G, int v) {\r\n         // TODO\r\n     }\r\n\r\n     /**\r\n      * Is there a path between the source s and vertex v?\r\n      * @param v the vertex\r\n      * @return true if there is a path, false otherwise\r\n      */\r\n     public boolean hasPathTo(int v) {\r\n         // TODO\r\n     }\r\n\r\n     /**\r\n      * Returns a path between the source vertex s and vertex v, or\r\n      * null if no such path\r\n      * @param v the vertex\r\n      * @return the sequence of vertices on a path between the source vertex\r\n      *         s and vertex v, as an Iterable\r\n      */\r\n     public Iterable&lt;Integer&gt; pathTo(int v) {\r\n         // TODO\r\n     }\r\n}</code></pre>\r\n<p>La classe <code>Graph</code> est déjà implémentée. En voici la spécification :</p>\r\n<pre class=\"java\"><code>public class Graph {\r\n    // @return the number of vertices\r\n    public int V() { }\r\n\r\n    // @return the number of edges\r\n    public int E() { }\r\n\r\n    // Add edge v-w to this graph\r\n    public void addEdge(int v, int w) { }\r\n\r\n    // @return the vertices adjacent to v\r\n    public Iterable&lt;Integer&gt; adj(int v) { }\r\n\r\n    // @return a string representation\r\n    public String toString() { }\r\n}</code></pre>\r\n<p><strong>Note:</strong> Les questions suivantes vous demanderont d'implémenter tous les <code>TODO</code> de la classe <code>DepthFirstPaths</code>. Vous n'avez pas besoin de mettre les accolades (<code>{ }</code>) entourant le corps de la fonction dans votre réponse.</p>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6DepthFirstPaths/LSINF1121_PART6_DepthFirstPaths.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6DepthFirstPaths",
            "archive_properties": {
                "folders": [
                    "Part6DepthFirstPaths"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Digraph (implem)",
            "description": "<p>Implémentez l'interface <code>Digraph.java</code> dans la classe <code>DigraphImplem.java</code> à l'aide d'une structure de donnée de type <code>liste d'adjacence</code> pour représenter les graphes dirigés.</p>\r\n<pre class=\"java\"><code>package student;\r\n\r\npublic interface Digraph {\r\n\r\n    /**\r\n     * The number of vertices\r\n     */\r\n    public int V();\r\n\r\n    /**\r\n     * The number of edges\r\n     */\r\n    public int E();\r\n\r\n    /**\r\n     * Add the edge v-&gt;w\r\n     */\r\n    public void addEdge(int v, int w);\r\n\r\n    /**\r\n     * The nodes adjacent to edge v\r\n     */\r\n    public Iterable&lt;Integer&gt; adj(int v);\r\n\r\n    /**\r\n     * A copy of the digraph with all edges reversed\r\n     */\r\n    public Digraph reverse();\r\n\r\n}</code></pre>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6Digraph/LSINF1121_PART6_Digraph.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6Digraph",
            "archive_properties": {
                "folders": [
                    "Part6Digraph"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Word Transformation Shortest Path (implem)",
            "description": "<p>On vous demande d'implémenter la classe <code>WordTransformationSP</code> qui permet de trouver le plus court chemin permettant de passer d'un string <em>A</em> à un autre string <em>B</em> (avec la certitude qu'il y a bien un chemin permettant de transformer <em>A</em> en <em>B</em>).</p>\r\n<p>Pour cela on definit une opération <code>rotation(x, y)</code> qui inverse l’ordre des lettres entre la position x et y (non-inclus). Par exemple, avec A=<code>HAMBURGER</code>, si l'on fait <code>rotation(A, 4, 8)</code>, cela nous donne <code>HAMBEGRUR</code>. Vous pouvez donc constater que la sous-string <code>URGE</code> a été inversé en <code>EGRU</code> et le reste de la chaine est resté inchangé: <code>HAMB</code> + <code>ECRU</code> + <code>R</code> = <code>HAMBEGRUR</code>.</p>\r\n<p>Disons qu’une <code>rotation(x, y)</code> a un cout de y-x. Par exemple passer de <code>HAMBURGER</code> à <code>HAMBEGRUR</code> coût <em>8-4 = 4</em>.</p>\r\n<p>La question est de savoir quel est le coût minimum pour atteindre une string B à partir A?</p>\r\n<p>Vous devez donc inmplémenter la méthode une fonction <code>public static int minimalCost(String A, String B)</code> qui retourne le cout minimal pour atteindre le String B depuis A en utilisant l'opération rotation.</p>\r\n<pre class=\"java\"><code>import java.util.*;\r\n\r\npublic  class WordTransformationSP {\r\n    /**\r\n     *\r\n     * Rotate the substring between start and end of a given string s\r\n     * eg. s = HAMBURGER, rotation(s,4,8) = HAMBEGRUR i.e. HAMB + EGRU + R\r\n     * @param s\r\n     * @param start\r\n     * @param end\r\n     * @return rotated string\r\n     */\r\n    public static String rotation(String s, int start, int end) {\r\n        return s.substring(0,start)+new StringBuilder(s.substring(start,end)).reverse().toString()+s.substring(end);\r\n    }\r\n\r\n    /**\r\n     * Compute the minimal cost from string &quot;from&quot; to string &quot;to&quot; representing the shortest path\r\n     * @param from\r\n     * @param to\r\n     * @return\r\n     */\r\n    public static int minimalCost(String from, String to) {\r\n        //TODO\r\n        return 0;\r\n    }\r\n}</code></pre>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6DijkstraForWordTransformation/LSINF1121_PART6_WordTransformation.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n<p><strong>Note:</strong> vous pouvez ajouter d'autres fonctions et des private classes si vous le désirez.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6DijkstraForWordTransformation",
            "archive_properties": {
                "folders": [
                    "Part6DijkstraForWordTransformation"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Global Warming (implem)",
            "description": "<h1 id=\"context\">Context</h1>\r\n<p>Supposons la matrice 5x5 suivante:</p>\r\n<pre class=\"java\"><code>int [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};</code></pre>\r\n<p>représentée dans le tableau ci-dessous :</p>\r\n<p><img src=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6GlobalWarming/matrix.png\" class=\"align-center\" width=\"200\" alt=\"matrix example\" /></p>\r\n<p>Chaque entrée de la matrice représente une altitude. L'objectif est d'implémenter une classe <span class=\"title-ref\">GlobalWarmingImpl</span> qui implémente toutes les méthodes décrites dans <span class=\"title-ref\">GlobalWarming</span> données ci-dessous.</p>\r\n<p>Un niveau d'eau global spécifié dans le constructeur modélise le fait que toutes les positions de la matrice avec une valeur &lt;= le niveau d'eau sont inondées (sous l'eau) et donc dangereuses. Dans l'exemple ci-dessus, le niveau d'eau est de 3, tous les points sûrs sont en vert.</p>\r\n<p>La méthode que vous devez implémenter doit permettre de calculer le chemin le plus court entre deux positions sont sur la même île</p>\r\n<p>nous supposons que les points sont <strong>uniquement connectés verticalement ou horizontalement</strong>.</p>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6GlobalWarming/LSINF1121_PART6_GlobalWarming.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n<pre class=\"java\"><code>import java.util.List;\r\n\r\nabstract class GlobalWarming {\r\n\r\n    /**\r\n     * A class to represent the coordinates on the altitude matrix\r\n     */\r\n    public static class Point {\r\n\r\n        final int x, y;\r\n\r\n        Point(int x, int y) {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n\r\n        @Override\r\n        public boolean equals(Object obj) {\r\n            Point p = (Point) obj;\r\n            return p.x == x &amp;&amp; p.y == y;\r\n        }\r\n    }\r\n\r\n    final int[][] altitude;\r\n    final int waterLevel;\r\n\r\n\r\n    /**\r\n     * In the following, we assume that the points are connected to\r\n     * horizontal or vertical neighbors but not to the diagonal ones\r\n     * @param altitude is a n x n matrix of int values representing altitudes (positive or negative)\r\n     * @param waterLevel is the water level, every entry &lt;= waterLevel is flooded\r\n     */\r\n    public GlobalWarming(int[][] altitude, int waterLevel) {\r\n        this.altitude = altitude;\r\n        this.waterLevel = waterLevel;\r\n    }\r\n\r\n\r\n    /**\r\n     *\r\n     * @param p1 a safe point with valid coordinates on altitude matrix\r\n     * @param p2 a safe point (different from p1) with valid coordinates on altitude matrix\r\n     * @return the shortest simple path (vertical/horizontal moves) if any between from p1 to p2 using only vertical/horizontal moves on safe points.\r\n     *         an empty list if not path exists (i.e. p1 and p2 are not on the same island).\r\n     */\r\n    public abstract List&lt;Point&gt; shortestPath(Point p1, Point p2);\r\n\r\n}</code></pre>\r\n<h1 id=\"exercices-preliminaires\">Exercices Preliminaires</h1>\r\n<pre class=\"java\"><code>int [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};\r\nGlobalWarming gw = new MyGlobalWarming(tab,3);</code></pre>\r\n<p><img src=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6GlobalWarming/matrix.png\" class=\"align-center\" width=\"200\" alt=\"matrix example\" /></p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6GlobalWarming",
            "archive_properties": {
                "folders": [
                    "Part6GlobalWarming"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "PART 6 : Maze (implem)",
            "description": "<p>Nous sommes intéressés par la résolution de labyrinthe (labyrinthe) représenté par une matrice d'entiers 0-1 de taille <span class=\"title-ref\">nxm</span>. Cette matrice est un tableau à deux dimensions. Une entrée égale à '1' signifie qu'il y a un mur et que cette position n'est donc pas accessible, tandis que '0' signifie que la position est libre.</p>\r\n<p>Nous vous demandons d'écrire un code Java pour découvrir le chemin le plus court entre deux coordonnées sur cette matrice de (x1, y1) à (x2, y2).</p>\r\n<p>Les déplacements ne peuvent être que verticaux ou horizontaux (pas en diagonale), un pas à la fois.</p>\r\n<p>Le résultat du chemin est un <code>Iterable</code> de coordonnées de l'origine à la destination. Ces coordonnées sont représentées par des entiers compris entre 0 et <span class=\"title-ref\">n * m-1</span>, où un entier 'a' représente la position <span class=\"title-ref\">x =a/m</span> et <span class=\"title-ref\">y=a%m</span>.</p>\r\n<p>Si la position de début ou de fin est un mur ou s’il n’ya pas de chemin, il faut renvoyer un <code>Iterable</code> vide. Il en va de même s'il n'y a pas de chemin entre l'origine et la destination.</p>\r\n<pre class=\"java\"><code>import java.util.LinkedList;\r\n\r\npublic class Maze {\r\n    public static Iterable&lt;Integer&gt; shortestPath(int [][] maze,  int x1, int y1, int x2, int y2) {\r\n        //TODO\r\n        return new LinkedList&lt;&gt;();\r\n    }\r\n\r\n    public static int ind(int x,int y, int lg) {return x*lg + y;}\r\n\r\n    public static int row(int pos, int mCols) { return pos / mCols; }\r\n\r\n    public static int col(int pos, int mCols) { return pos % mCols; }\r\n}</code></pre>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6Maze/LSINF1121_PART6_Maze.zip\">Le projet IntelliJ est disponible ici</a>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6Maze",
            "archive_properties": {
                "folders": [
                    "Part6Maze"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Règles de participation aux cours",
            "description": "<h1 id=\"ce-qui-est-interdit\">Ce qui est interdit</h1>\r\n<p>Il est interdit de partager son code avec un autre groupe et même avec son propre groupe pour les parties individuelles des missions.</p>\r\n<p>Il est interdit de publier son code de manière publique (<code>GitHub</code>, <code>Bitbucket</code>, <code>Dropbox</code> ou <code>Drive</code> partagé, etc) pendant et après le quadrimestre. Nous vous fournirons un repository <code>Git</code> pour vos travaux de groupes, qui sera seulement visible par les membres de votre groupe.</p>\r\n<p>Il est interdit de prendre le code de quelqu’un d’autre (même partiellement), y compris du code disponible sur le web. Seul le code fourni dans le livre de référence peut être utilisé.</p>\r\n<h1 id=\"ce-qui-est-autorisé\">Ce qui est autorisé</h1>\r\n<p>Échanger et discuter des idées avec des collègues (y compris d’un autre groupe) est autorisé (oralement autour d’un tableau, sur un forum, etc). Mais il est interdit de demander et/ou fournir une réponse toute faite ou du code source.</p>\r\n<p>Exemple de ce qui est interdit :</p>\r\n<ul>\r\n<li>Tu as mis quoi à la réponse à la question 1 ?</li>\r\n</ul>\r\n<p>Exemple de ce qui est autorisé :</p>\r\n<ul>\r\n<li>J’hésite entre la méthode 1 et la méthode 2 pour réaliser l’objectif 1, je pense que la méthode 1 est meilleure pour la raison x, que penses-tu de cet argument ?</li>\r\n</ul>\r\n<h1 id=\"pourquoi\">Pourquoi ?</h1>\r\n<p>Car le matériel pédagogique mis en place s’améliore chaque année et prend beaucoup de temps à développer. Le copyright de celui-ci appartient d’ailleurs à l’UCL et non aux étudiants.</p>\r\n<p>Contourner les outils pédagogiques mis en place (par exemple en empruntant du code déjà écrit) ne vous rend pas service. C’est même le meilleur moyen d’échouer à l’examen qui visera précisément à évaluer les compétences acquises: programmation, réponses aux questions, etc.</p>\r\n<p>En partageant du code ou des réponses (dans le meilleur des cas approximativement correctes...) vous inciteriez certains étudiants à ne pas réfléchir par eux-mêmes, voir pire, à apprendre des réponses potentiellement erronées.</p>\r\n<p>La note de participation ne vise pas l’exactitude des productions (réponses, codes) mais l’attitude et la motivation de l’étudiant à s’améliorer et acquérir les compétences visées.</p>\r\n<h1 id=\"risque\">Risque</h1>\r\n<p>Tout manquement à un de ces points sera sanctionné comme un acte de tricherie et sera dès lors reporté au président des jurys. Pour rappel, en cas de tricherie, l'étudiant peut se voir attribuer un zéro pour le cours, voire se voir attribuer zéro pour l'ensemble des cours de la session.</p>\r\n<p>Vos codes sont analysés par des outils de détection de plagiat. Un étudiant averti en vaut deux.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Kaczynski Frédéric",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/participation_rules",
            "archive_properties": {
                "folders": [
                    "participation_rules"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Rabin Karp",
            "description": "<p>A la page 777 du livre \"Algorithms\" 4th edition, on vous propose l'implémentation suivante de l'algorithme de Rabin Karp.</p>\r\n<pre class=\"java\"><code>public class RabinKarp {\r\n  private String pat;      // the pattern  // needed only for Las Vegas\r\n  private long patHash;    // pattern hash value\r\n  private int m;           // pattern length\r\n  private long q;          // a large prime, small enough to avoid long overflow\r\n  private int R;           // radix\r\n  private long RM;         // R^(M-1) % Q\r\n\r\n  public RabinKarp(String pat) {\r\n      this.pat = pat;      // save pattern (needed only for Las Vegas)\r\n      R = 256;\r\n      m = pat.length();\r\n      q = longRandomPrime();\r\n\r\n      // precompute R^(m-1) % q for use in removing leading digit\r\n      RM = 1;\r\n      for (int i = 1; i &lt;= m-1; i++)\r\n          RM = (R * RM) % q;\r\n      patHash = hash(pat, m);\r\n  }\r\n\r\n  // Compute hash for key[0..m-1].\r\n  private long hash(String key, int m) {\r\n      long h = 0;\r\n      for (int j = 0; j &lt; m; j++)\r\n          h = (R * h + key.charAt(j)) % q;\r\n      return h;\r\n  }\r\n\r\n  // Monte Carlo\r\n  private boolean check(int i) {\r\n      return true;\r\n  }\r\n\r\n  // Returns the index of the first occurrrence of the pattern string in the text string.\r\n  public int search(String txt) {\r\n      int n = txt.length();\r\n      if (n &lt; m) return n;\r\n      long txtHash = hash(txt, m);\r\n\r\n      // check for match at offset 0\r\n      if ((patHash == txtHash) &amp;&amp; check(txt, 0))\r\n          return 0;\r\n\r\n      // check for hash match; if hash match, check for exact match\r\n      for (int i = m; i &lt; n; i++) {\r\n          // Remove leading digit, add trailing digit, check for match.\r\n          txtHash = (txtHash + q - RM*txt.charAt(i-m) % q) % q;\r\n          txtHash = (txtHash*R + txt.charAt(i)) % q;\r\n\r\n          // match\r\n          int offset = i - m + 1;\r\n          if ((patHash == txtHash) &amp;&amp; check(txt, offset))\r\n              return offset;\r\n      }\r\n\r\n      // no match\r\n      return n;\r\n  }\r\n\r\n\r\n  // a random 31-bit prime\r\n  private static long longRandomPrime() {\r\n      BigInteger prime = BigInteger.probablePrime(31, new Random());\r\n      return prime.longValue();\r\n  }\r\n\r\n}</code></pre>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Xavier Gillard",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                },
                {
                    "category": 2,
                    "text": "Mission 4"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/preexamen_rabinkarp",
            "archive_properties": {
                "folders": [
                    "preexamen_rabinkarp"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Breadth First Paths",
            "description": "<p>Consider this class, <code>BreadthFirstShortestPaths</code>, that computes the shortest path between multiple node sources and any node in an undirected graph.</p>\r\n<pre class=\"java\"><code>// TODO\r\n\r\npublic class BreadthFirstShortestPaths {\r\n\r\n    private static final int INFINITY = Integer.MAX_VALUE;\r\n    private boolean[] marked; // marked[v] = is there an s-v path\r\n    private int[] distTo;     // distTo[v] = number of edges shortest s-v path\r\n\r\n    /**\r\n     * Computes the shortest path between any\r\n     * one of the sources and very other vertex\r\n     * @param G the graph\r\n     * @param sources the source vertices\r\n     */\r\n     public BreadthFirstShortestPaths(Graph G, Iterable&lt;Integer&gt; sources) {\r\n         marked = new boolean[G.V()];\r\n         distTo = new int[G.V()];\r\n         for (int v = 0;v &lt; G.V();v++) {\r\n             distTo[v] = INFINITY;\r\n         }\r\n         bfs(G, sources);\r\n     }\r\n\r\n     // Breadth-first search from multiple sources\r\n     private void bfs(Graph G, Iterable&lt;Integer&gt; sources) {\r\n         // TODO\r\n     }\r\n\r\n     /**\r\n      * Is there a path between (at least one of) the sources and vertex v?\r\n      * @param v the vertex\r\n      * @return true if there is a path, and false otherwise\r\n      */\r\n     public boolean hasPathTo(int v) {\r\n         // TODO\r\n     }\r\n\r\n     /**\r\n      * Returns the number of edges in a shortest path\r\n      * between one of the sources and vertex v?\r\n      * @param v the vertex\r\n      * @return the number of edges in a shortest path\r\n      */\r\n     public int distTo(int v) {\r\n         // TODO\r\n     }\r\n}</code></pre>\r\n<p>The class <code>Graph</code> is already implemented. Here is its specification:</p>\r\n<pre class=\"java\"><code>public class Graph {\r\n    // @return the number of vertices\r\n    public int V() { }\r\n\r\n    // @return the number of edges\r\n    public int E() { }\r\n\r\n    // Add edge v-w to this graph\r\n    public void addEdge(int v, int w) { }\r\n\r\n    // @return the vertices adjacent to v\r\n    public Iterable&lt;Integer&gt; adj(int v) { }\r\n\r\n    // @return a string representation\r\n    public String toString() { }\r\n}</code></pre>\r\n<p><strong>Note:</strong> The following questions will ask you to implement the function left out. You don't need to put the brackets (<code>{ }</code>) surrounding the function body in your answer.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "category": 2,
                    "text": "Mission 6"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/preexam_bfs",
            "archive_properties": {
                "folders": [
                    "preexam_bfs"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Bloom Filters",
            "description": "<h1 id=\"les-filtres-de-bloom\">Les filtres de Bloom</h1>\r\n<p>Un filtre de Bloom, est une structure de donnée très compacte et efficace qui permet d'implémenter un test d'appartenance rapide (<code>.contains()</code>) à un très grand <em>ensemble</em>. Cependant, contrairement au test d'appartenance à un ensemble tel qu'implémenté à l'aide d'une HashMap, le test d'appartenance implémenté via un filtre de bloom peut renvoyer un résultat erroné (faux positifs possibles mais pas de faux négatifs) dans certains cas et cela, avec une faible probabilité.</p>\r\n<p>L'efficacité de cette structure, et le fait qu'elle ne requière qu'une quantité très faible (et constante !) de mémoire quel que soit le nombre d'éléments contenus dans l'ensemble en ont fait une structure de choix pour un très grand nombre d'applications. A titre d'exemple, on mentionnera le fait que les filtres de Bloom sont utilisés par certains devices réseaux pour faire du <em>Deep Packet Inspection</em>, ou encore que les bases de données <em>Google Big Table</em>, <em>Apache Cassandra</em> ou encore <em>Postgresql</em> utilisent cette structure de donnée afin de tester si une donnée se trouve en cache ou non.</p>\r\n<p>En effet la recherche de la donnée étant généralement coûteuse, un filtre de Bloom est utilisé pour éviter de faire une recherche si la donnée n'est pas présente. Par contre, comme les erreurs de type faux-positifs sont possibles, le filtre de Bloom peut dire que la donnée s'y trouve alors que ça n'est pas vrai. Dans ce cas, il faudra effectuer la recherche pour vérifier et payer le coût de cette recherche (par exemple une recherche linéaire avec des accès sur le disque).</p>\r\n<h1 id=\"concrètement\">Concrètement</h1>\r\n<p>Concrètement, un filtre de bloom consiste en un vecteur <span class=\"math inline\"><em>V</em> = <em>v</em><sub>1</sub>..<em>v</em><sub><em>n</em></sub></span> de bit et d'un ensemble <span class=\"math inline\"><em>F</em> = <em>f</em><sub>1</sub>..<em>f</em><sub><em>k</em></sub></span> de fonctions de hachage</p>\r\n<p>Pour ajouter un élément <span class=\"math inline\"><em>X</em></span> dans le set, on applique successivement chacune des fonctions <span class=\"math inline\"><em>f</em><sub><em>i</em></sub> ∈ <em>F</em></span> de hachage. L'application de chacune de ces fonctions à l'élément <span class=\"math inline\"><em>X</em></span> renvoie un nombre <span class=\"math inline\"><em>h</em><sub><em>i</em></sub> ∈ [0..<em>n</em>−1]</span>. Pour marquer l'ajout de <span class=\"math inline\"><em>X</em></span> au filtre de bloom, on met à 1 simplement chacun des <span class=\"math inline\"><em>v</em><sub><em>h</em><sub><em>i</em></sub></sub></span> bits dans <span class=\"math inline\"><em>V</em></span>.</p>\r\n<p>De façon similaire, pour tester l'appartenance d'un élément <span class=\"math inline\"><em>X</em></span> au set, on vérifie que le <span class=\"math inline\"><em>h</em><sub><em>i</em></sub></span> ème bit <span class=\"math inline\"> ∈ <em>V</em></span> correspondant à <span class=\"math inline\"><em>f</em><sub><em>i</em></sub>(<em>X</em>)</span> est égal à 1. Le test d'appartenance ne renverra <span class=\"title-ref\">true</span> que ssi, cette condition est vérifiée pour chacune des <span class=\"math inline\"><em>f</em><sub><em>i</em></sub> ∈ <em>F</em></span>.</p>\r\n<h2 id=\"exemples\">Exemples</h2>\r\n<p>En supposant qu'on ait un filtre de Bloom représenté par 1 byte et 3 fonctions de hachage telles que:</p>\r\n<pre class=\"\"><code>f1(&quot;Salut&quot;) = 0\r\nf2(&quot;Salut&quot;) = 1\r\nf3(&quot;Salut&quot;) = 2\r\n\r\net\r\n\r\nf1(&quot;1121&quot;) = 0\r\nf2(&quot;1121&quot;) = 1\r\nf3(&quot;1121&quot;) = 4</code></pre>\r\n<p>L'ajout de \"Salut\" au filtre 00000000 transforme celui-ci en 11100000. Si par la suite on veut tester que \"Salut\" est bien présent dans le filtre, on s'assure que les bits v1, v2 et v3 sont bien égaux à 1.</p>\r\n<p>En continuant sur le même exemple, on voit que la chaine \"1121\" n'est pas présente dans la structure puisque le 4eme bit est égal à 0.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Xavier Gillard",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "exam"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/preexam_bloomfilter",
            "archive_properties": {
                "folders": [
                    "preexam_bloomfilter"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Depth First Paths",
            "description": "<p>Consider this class, <code>DepthFirstPaths</code>, that computes paths to any connected node from a source node <code>s</code> in an undirected graph.</p>\r\n<pre class=\"java\"><code>// TODO\r\n\r\npublic class DepthFirstPaths {\r\n    private boolean[] marked; // marked[v] = is there an s-v path?\r\n    private int[] edgeTo;     // edgeTo[v] = last edge on s-v path\r\n    private final int s;\r\n\r\n    /**\r\n     * Computes a path between s and every other vertex in graph G\r\n     * @param G the graph\r\n     * @param s the source vertex\r\n     */\r\n     public DepthFirstPaths(Graph G, int s) {\r\n         this.s = s;\r\n         edgeTo = new int[G.V()];\r\n         marked = new boolean[G.V()];\r\n         dfs(G, s);\r\n     }\r\n\r\n     // Depth first search from v\r\n     private void dfs(Graph G, int v) {\r\n         // TODO\r\n     }\r\n\r\n     /**\r\n      * Is there a path between the source s and vertex v?\r\n      * @param v the vertex\r\n      * @return true if there is a path, false otherwise\r\n      */\r\n     public boolean hasPathTo(int v) {\r\n         // TODO\r\n     }\r\n\r\n     /**\r\n      * Returns a path between the source vertex s and vertex v, or\r\n      * null if no such path\r\n      * @param v the vertex\r\n      * @return the sequence of vertices on a path between the source vertex\r\n      *         s and vertex v, as an Iterable\r\n      */\r\n     public Iterable&lt;Integer&gt; pathTo(int v) {\r\n         // TODO\r\n     }\r\n}</code></pre>\r\n<p>The class <code>Graph</code> is already implemented. Here is its specification:</p>\r\n<pre class=\"java\"><code>public class Graph {\r\n    // @return the number of vertices\r\n    public int V() { }\r\n\r\n    // @return the number of edges\r\n    public int E() { }\r\n\r\n    // Add edge v-w to this graph\r\n    public void addEdge(int v, int w) { }\r\n\r\n    // @return the vertices adjacent to v\r\n    public Iterable&lt;Integer&gt; adj(int v) { }\r\n\r\n    // @return a string representation\r\n    public String toString() { }\r\n}</code></pre>\r\n<p><strong>Note:</strong> The following questions will ask you to implement the function left out. You don't need to put the brackets (<code>{ }</code>) surrounding the function body in your answer.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "category": 2,
                    "text": "Mission 6"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/preexam_dfs",
            "archive_properties": {
                "folders": [
                    "preexam_dfs"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Heap",
            "description": "<p>Consider the <code>Heap</code> data structure in which we progressively add numbers.</p>\r\n<p>The following questions will ask you to write a representation of the <code>Heap</code> as we add objects in it. You must write the <code>Heap</code> as if it was stored in an array. For example, if your answer is:</p>\r\n<pre><code>9\r\n/ \\\r\n5   8\r\n/ \\\r\n4   3</code></pre>\r\n<p>You would write:</p>\r\n<pre><code>9 5 8 4 3</code></pre>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                },
                {
                    "category": 2,
                    "text": "Mission 5"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/preexam_heap",
            "archive_properties": {
                "folders": [
                    "preexam_heap"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Merge Sort",
            "description": "<p>Consider the (top-down) sorting algorithm <code>Merge Sort</code></p>\r\n<pre class=\"java\"><code>public class MergeSort {\r\n    /**\r\n     * Pre-conditions: a[lo..mid] and a[mid+1..hi] are sorted\r\n     * Post-conditions: a[lo..hi] is sorted\r\n     */\r\n    private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) {\r\n        for (int k = lo; k &lt;= hi; k++) {\r\n            aux[k] = a[k];\r\n        }\r\n\r\n        int i = lo;\r\n        int j = mid + 1;\r\n        for (int k = lo; k &lt;= hi; k++) {\r\n            if (i &gt; mid) {\r\n                a[k] = aux[j++];\r\n            } else if (j &gt; hi) {\r\n                a[k] = aux[i++];\r\n            } else if (aux[j].compareTo(aux[i]) &lt; 0) {\r\n                a[k] = aux[j++];\r\n            } else {\r\n                a[k] = aux[i++];\r\n            }\r\n        }\r\n    }\r\n\r\n    // Mergesort a[lo..hi] using auxiliary array aux[lo..hi]\r\n    private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) {\r\n        // TODO\r\n    }\r\n\r\n    /**\r\n     * Rearranges the array in ascending order, using the natural order\r\n     */\r\n    public static void sort(Comparable[] a) {\r\n        // TODO\r\n    }\r\n}</code></pre>\r\n<p><strong>Note:</strong> The following questions will ask you to implement the function left out. You don't need to put the brackets (<code>{ }</code>) surrounding the function body in your answer.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "category": 2,
                    "text": "Mission 2"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/preexam_merge_sort",
            "archive_properties": {
                "folders": [
                    "preexam_merge_sort"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Red Black Tree",
            "description": "<p>Consider an empty <code>Red-Black Tree</code> in which we progressively add numbers.</p>\r\n<p>The following questions will ask you to write a representation of the <code>Red-Black Tree</code> as we add objects in it. Write it as if you were reading from left to right and from top to bottom (ignoring the possible blanks). For example, if your answer is:</p>\r\n<pre><code>6\r\n/   \\\r\n(2 4)   7\r\n/ | \\    \\\r\n1  3  5    9</code></pre>\r\n<p>You would write:</p>\r\n<pre><code>6 24 7 1 3 5 9</code></pre>\r\n<p>Notice how the 2-3 node composed of <code>2</code> and <code>4</code> is written in a merged way (<code>24</code>).</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                },
                {
                    "category": 2,
                    "text": "Mission 3"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/preexam_redblacktree",
            "archive_properties": {
                "folders": [
                    "preexam_redblacktree"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "QCM Binary Trees",
            "description": "<p>Consider this ordered binary tree:</p>\r\n<pre><code>4\r\n/   \\\r\n2       5\r\n/ \\     / \\\r\n1   3   6   7</code></pre>\r\n<p>We traverse this tree and we print the value of each node we visit it.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                },
                {
                    "category": 2,
                    "text": "Mission 3"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/preexam_tree_qcm",
            "archive_properties": {
                "folders": [
                    "preexam_tree_qcm"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Union find",
            "description": "<p>Consider a graph made of 10 disjoint nodes (numbered from 0 to 9). We use a union-find data structure to represent this graph. At first, each node is contained in a partition named after the node. Thus, the representation of the graph in the array <code>id[]</code> is:</p>\r\n<pre><code>0 1 2 3 4 5 6 7 8 9</code></pre>\r\n<p>The following questions will ask you to type the representation of the graph after we use the <strong>quick-find</strong> algorithm to add an edge between 2 nodes. You must type this representation in the same way it was typed above.</p>\r\n<p><strong>Note:</strong> When we join <code>p-q</code> with the quick-find algorithm, the convention is to change <code>id[p]</code> (and potentially other entries) but not <code>id[q]</code>.</p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                },
                {
                    "category": 2,
                    "text": "Mission 5"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/preexam_unionfind",
            "archive_properties": {
                "folders": [
                    "preexam_unionfind"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Binary Search Tree",
            "description": "<p>Etant donné un arbre de recherche binaire, dont les noeuds implémentent l'interface Node:</p>\r\n<pre class=\"java\"><code>interface Node {\r\n    /**\r\n      * @return la valeur contenue dans ce noeud\r\n      */\r\n    int getValue();\r\n\r\n    /**\r\n     * @return Le noeud situe a gauche (dont la valeur est &lt; que la valeur actuelle) s&#39;il existe, null sinon\r\n     */\r\n    Node getLeft();\r\n\r\n    /**\r\n      * @return Le noeud situe a droite (dont la valeur est &gt; que la valeur actuelle) s&#39;il existe, null sinon\r\n      */\r\n    Node getRight();\r\n}</code></pre>\r\n<p>L'on vous demande de fournir le <strong>corps</strong> de la fonction <em>ceil</em>, qui trouve dans l'arbre le plus petit élément plus grand ou égal à <span class=\"title-ref\">value</span> (donc soit l'élément lui-même soit l'élément situé directement après par ordre de grandeur). Si un tel élément n'existe pas, elle doit retourner <span class=\"title-ref\">null</span>.</p>\r\n<p><a href=\"https://inginious.info.ucl.ac.be/course/LSINF1121-2016/whiteexam2016bst/project.zip\">Un projet Eclipse contenant des tests basiques vous est fourni en cliquant sur ce lien.</a></p>\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Guillaume Derval",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "category": 2,
                    "text": "Mission 3"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/whiteexam2016bst",
            "archive_properties": {
                "folders": [
                    "whiteexam2016bst"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Questions à choix multiples",
            "description": "\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "CC-BY-NC-SA-4.0",
                    "autoGenerated": true,
                    "category_id": "_LICENSE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Antoine Cailliau",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                },
                {
                    "category": 2,
                    "text": "Mission 3"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/whiteexam2016qcm",
            "archive_properties": {
                "folders": [
                    "whiteexam2016qcm"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        }
    ],
    "own_categories": {
        "0": "thématique",
        "1": "Misconception",
        "2": "autres"
    },
    "extraction_date": "2020-03-04T17:50:17.245Z",
    "url": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms"
}